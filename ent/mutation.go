// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"golang-backend/ent/ansprechpartner"
	"golang-backend/ent/artikel"
	"golang-backend/ent/inventur"
	"golang-backend/ent/lieferant"
	"golang-backend/ent/mitarbeiter"
	"golang-backend/ent/predicate"
	"golang-backend/ent/team"
	"golang-backend/ent/user"
	"golang-backend/ent/version"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnsprechpartner = "Ansprechpartner"
	TypeArtikel         = "Artikel"
	TypeInventur        = "Inventur"
	TypeLieferant       = "Lieferant"
	TypeMitarbeiter     = "Mitarbeiter"
	TypeTeam            = "Team"
	TypeUser            = "User"
	TypeVersion         = "Version"
)

// AnsprechpartnerMutation represents an operation that mutates the Ansprechpartner nodes in the graph.
type AnsprechpartnerMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Name             *string
	_Telefon          *string
	_Mobil            *string
	_Mail             *string
	clearedFields     map[string]struct{}
	_Lieferant        *int
	cleared_Lieferant bool
	done              bool
	oldValue          func(context.Context) (*Ansprechpartner, error)
	predicates        []predicate.Ansprechpartner
}

var _ ent.Mutation = (*AnsprechpartnerMutation)(nil)

// ansprechpartnerOption allows management of the mutation configuration using functional options.
type ansprechpartnerOption func(*AnsprechpartnerMutation)

// newAnsprechpartnerMutation creates new mutation for the Ansprechpartner entity.
func newAnsprechpartnerMutation(c config, op Op, opts ...ansprechpartnerOption) *AnsprechpartnerMutation {
	m := &AnsprechpartnerMutation{
		config:        c,
		op:            op,
		typ:           TypeAnsprechpartner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnsprechpartnerID sets the ID field of the mutation.
func withAnsprechpartnerID(id int) ansprechpartnerOption {
	return func(m *AnsprechpartnerMutation) {
		var (
			err   error
			once  sync.Once
			value *Ansprechpartner
		)
		m.oldValue = func(ctx context.Context) (*Ansprechpartner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ansprechpartner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnsprechpartner sets the old Ansprechpartner of the mutation.
func withAnsprechpartner(node *Ansprechpartner) ansprechpartnerOption {
	return func(m *AnsprechpartnerMutation) {
		m.oldValue = func(context.Context) (*Ansprechpartner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnsprechpartnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnsprechpartnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnsprechpartnerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnsprechpartnerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ansprechpartner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *AnsprechpartnerMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *AnsprechpartnerMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Ansprechpartner entity.
// If the Ansprechpartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsprechpartnerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *AnsprechpartnerMutation) ResetName() {
	m._Name = nil
}

// SetTelefon sets the "Telefon" field.
func (m *AnsprechpartnerMutation) SetTelefon(s string) {
	m._Telefon = &s
}

// Telefon returns the value of the "Telefon" field in the mutation.
func (m *AnsprechpartnerMutation) Telefon() (r string, exists bool) {
	v := m._Telefon
	if v == nil {
		return
	}
	return *v, true
}

// OldTelefon returns the old "Telefon" field's value of the Ansprechpartner entity.
// If the Ansprechpartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsprechpartnerMutation) OldTelefon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelefon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelefon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelefon: %w", err)
	}
	return oldValue.Telefon, nil
}

// ClearTelefon clears the value of the "Telefon" field.
func (m *AnsprechpartnerMutation) ClearTelefon() {
	m._Telefon = nil
	m.clearedFields[ansprechpartner.FieldTelefon] = struct{}{}
}

// TelefonCleared returns if the "Telefon" field was cleared in this mutation.
func (m *AnsprechpartnerMutation) TelefonCleared() bool {
	_, ok := m.clearedFields[ansprechpartner.FieldTelefon]
	return ok
}

// ResetTelefon resets all changes to the "Telefon" field.
func (m *AnsprechpartnerMutation) ResetTelefon() {
	m._Telefon = nil
	delete(m.clearedFields, ansprechpartner.FieldTelefon)
}

// SetMobil sets the "Mobil" field.
func (m *AnsprechpartnerMutation) SetMobil(s string) {
	m._Mobil = &s
}

// Mobil returns the value of the "Mobil" field in the mutation.
func (m *AnsprechpartnerMutation) Mobil() (r string, exists bool) {
	v := m._Mobil
	if v == nil {
		return
	}
	return *v, true
}

// OldMobil returns the old "Mobil" field's value of the Ansprechpartner entity.
// If the Ansprechpartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsprechpartnerMutation) OldMobil(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobil: %w", err)
	}
	return oldValue.Mobil, nil
}

// ClearMobil clears the value of the "Mobil" field.
func (m *AnsprechpartnerMutation) ClearMobil() {
	m._Mobil = nil
	m.clearedFields[ansprechpartner.FieldMobil] = struct{}{}
}

// MobilCleared returns if the "Mobil" field was cleared in this mutation.
func (m *AnsprechpartnerMutation) MobilCleared() bool {
	_, ok := m.clearedFields[ansprechpartner.FieldMobil]
	return ok
}

// ResetMobil resets all changes to the "Mobil" field.
func (m *AnsprechpartnerMutation) ResetMobil() {
	m._Mobil = nil
	delete(m.clearedFields, ansprechpartner.FieldMobil)
}

// SetMail sets the "Mail" field.
func (m *AnsprechpartnerMutation) SetMail(s string) {
	m._Mail = &s
}

// Mail returns the value of the "Mail" field in the mutation.
func (m *AnsprechpartnerMutation) Mail() (r string, exists bool) {
	v := m._Mail
	if v == nil {
		return
	}
	return *v, true
}

// OldMail returns the old "Mail" field's value of the Ansprechpartner entity.
// If the Ansprechpartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnsprechpartnerMutation) OldMail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMail: %w", err)
	}
	return oldValue.Mail, nil
}

// ClearMail clears the value of the "Mail" field.
func (m *AnsprechpartnerMutation) ClearMail() {
	m._Mail = nil
	m.clearedFields[ansprechpartner.FieldMail] = struct{}{}
}

// MailCleared returns if the "Mail" field was cleared in this mutation.
func (m *AnsprechpartnerMutation) MailCleared() bool {
	_, ok := m.clearedFields[ansprechpartner.FieldMail]
	return ok
}

// ResetMail resets all changes to the "Mail" field.
func (m *AnsprechpartnerMutation) ResetMail() {
	m._Mail = nil
	delete(m.clearedFields, ansprechpartner.FieldMail)
}

// SetLieferantID sets the "Lieferant" edge to the Lieferant entity by id.
func (m *AnsprechpartnerMutation) SetLieferantID(id int) {
	m._Lieferant = &id
}

// ClearLieferant clears the "Lieferant" edge to the Lieferant entity.
func (m *AnsprechpartnerMutation) ClearLieferant() {
	m.cleared_Lieferant = true
}

// LieferantCleared reports if the "Lieferant" edge to the Lieferant entity was cleared.
func (m *AnsprechpartnerMutation) LieferantCleared() bool {
	return m.cleared_Lieferant
}

// LieferantID returns the "Lieferant" edge ID in the mutation.
func (m *AnsprechpartnerMutation) LieferantID() (id int, exists bool) {
	if m._Lieferant != nil {
		return *m._Lieferant, true
	}
	return
}

// LieferantIDs returns the "Lieferant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LieferantID instead. It exists only for internal usage by the builders.
func (m *AnsprechpartnerMutation) LieferantIDs() (ids []int) {
	if id := m._Lieferant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLieferant resets all changes to the "Lieferant" edge.
func (m *AnsprechpartnerMutation) ResetLieferant() {
	m._Lieferant = nil
	m.cleared_Lieferant = false
}

// Where appends a list predicates to the AnsprechpartnerMutation builder.
func (m *AnsprechpartnerMutation) Where(ps ...predicate.Ansprechpartner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnsprechpartnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnsprechpartnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ansprechpartner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnsprechpartnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnsprechpartnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ansprechpartner).
func (m *AnsprechpartnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnsprechpartnerMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Name != nil {
		fields = append(fields, ansprechpartner.FieldName)
	}
	if m._Telefon != nil {
		fields = append(fields, ansprechpartner.FieldTelefon)
	}
	if m._Mobil != nil {
		fields = append(fields, ansprechpartner.FieldMobil)
	}
	if m._Mail != nil {
		fields = append(fields, ansprechpartner.FieldMail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnsprechpartnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ansprechpartner.FieldName:
		return m.Name()
	case ansprechpartner.FieldTelefon:
		return m.Telefon()
	case ansprechpartner.FieldMobil:
		return m.Mobil()
	case ansprechpartner.FieldMail:
		return m.Mail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnsprechpartnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ansprechpartner.FieldName:
		return m.OldName(ctx)
	case ansprechpartner.FieldTelefon:
		return m.OldTelefon(ctx)
	case ansprechpartner.FieldMobil:
		return m.OldMobil(ctx)
	case ansprechpartner.FieldMail:
		return m.OldMail(ctx)
	}
	return nil, fmt.Errorf("unknown Ansprechpartner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnsprechpartnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ansprechpartner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ansprechpartner.FieldTelefon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelefon(v)
		return nil
	case ansprechpartner.FieldMobil:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobil(v)
		return nil
	case ansprechpartner.FieldMail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMail(v)
		return nil
	}
	return fmt.Errorf("unknown Ansprechpartner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnsprechpartnerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnsprechpartnerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnsprechpartnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ansprechpartner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnsprechpartnerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ansprechpartner.FieldTelefon) {
		fields = append(fields, ansprechpartner.FieldTelefon)
	}
	if m.FieldCleared(ansprechpartner.FieldMobil) {
		fields = append(fields, ansprechpartner.FieldMobil)
	}
	if m.FieldCleared(ansprechpartner.FieldMail) {
		fields = append(fields, ansprechpartner.FieldMail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnsprechpartnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnsprechpartnerMutation) ClearField(name string) error {
	switch name {
	case ansprechpartner.FieldTelefon:
		m.ClearTelefon()
		return nil
	case ansprechpartner.FieldMobil:
		m.ClearMobil()
		return nil
	case ansprechpartner.FieldMail:
		m.ClearMail()
		return nil
	}
	return fmt.Errorf("unknown Ansprechpartner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnsprechpartnerMutation) ResetField(name string) error {
	switch name {
	case ansprechpartner.FieldName:
		m.ResetName()
		return nil
	case ansprechpartner.FieldTelefon:
		m.ResetTelefon()
		return nil
	case ansprechpartner.FieldMobil:
		m.ResetMobil()
		return nil
	case ansprechpartner.FieldMail:
		m.ResetMail()
		return nil
	}
	return fmt.Errorf("unknown Ansprechpartner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnsprechpartnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Lieferant != nil {
		edges = append(edges, ansprechpartner.EdgeLieferant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnsprechpartnerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ansprechpartner.EdgeLieferant:
		if id := m._Lieferant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnsprechpartnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnsprechpartnerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnsprechpartnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Lieferant {
		edges = append(edges, ansprechpartner.EdgeLieferant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnsprechpartnerMutation) EdgeCleared(name string) bool {
	switch name {
	case ansprechpartner.EdgeLieferant:
		return m.cleared_Lieferant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnsprechpartnerMutation) ClearEdge(name string) error {
	switch name {
	case ansprechpartner.EdgeLieferant:
		m.ClearLieferant()
		return nil
	}
	return fmt.Errorf("unknown Ansprechpartner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnsprechpartnerMutation) ResetEdge(name string) error {
	switch name {
	case ansprechpartner.EdgeLieferant:
		m.ResetLieferant()
		return nil
	}
	return fmt.Errorf("unknown Ansprechpartner edge %s", name)
}

// ArtikelMutation represents an operation that mutates the Artikel nodes in the graph.
type ArtikelMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Artikelnummer *string
	_Suchbegriff   *string
	_Anzahl        *int
	add_Anzahl     *int
	clearedFields  map[string]struct{}
	team           *int
	clearedteam    bool
	done           bool
	oldValue       func(context.Context) (*Artikel, error)
	predicates     []predicate.Artikel
}

var _ ent.Mutation = (*ArtikelMutation)(nil)

// artikelOption allows management of the mutation configuration using functional options.
type artikelOption func(*ArtikelMutation)

// newArtikelMutation creates new mutation for the Artikel entity.
func newArtikelMutation(c config, op Op, opts ...artikelOption) *ArtikelMutation {
	m := &ArtikelMutation{
		config:        c,
		op:            op,
		typ:           TypeArtikel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withArtikelID sets the ID field of the mutation.
func withArtikelID(id int) artikelOption {
	return func(m *ArtikelMutation) {
		var (
			err   error
			once  sync.Once
			value *Artikel
		)
		m.oldValue = func(ctx context.Context) (*Artikel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Artikel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArtikel sets the old Artikel of the mutation.
func withArtikel(node *Artikel) artikelOption {
	return func(m *ArtikelMutation) {
		m.oldValue = func(context.Context) (*Artikel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ArtikelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ArtikelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ArtikelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ArtikelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Artikel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArtikelnummer sets the "Artikelnummer" field.
func (m *ArtikelMutation) SetArtikelnummer(s string) {
	m._Artikelnummer = &s
}

// Artikelnummer returns the value of the "Artikelnummer" field in the mutation.
func (m *ArtikelMutation) Artikelnummer() (r string, exists bool) {
	v := m._Artikelnummer
	if v == nil {
		return
	}
	return *v, true
}

// OldArtikelnummer returns the old "Artikelnummer" field's value of the Artikel entity.
// If the Artikel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtikelMutation) OldArtikelnummer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArtikelnummer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArtikelnummer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArtikelnummer: %w", err)
	}
	return oldValue.Artikelnummer, nil
}

// ResetArtikelnummer resets all changes to the "Artikelnummer" field.
func (m *ArtikelMutation) ResetArtikelnummer() {
	m._Artikelnummer = nil
}

// SetSuchbegriff sets the "Suchbegriff" field.
func (m *ArtikelMutation) SetSuchbegriff(s string) {
	m._Suchbegriff = &s
}

// Suchbegriff returns the value of the "Suchbegriff" field in the mutation.
func (m *ArtikelMutation) Suchbegriff() (r string, exists bool) {
	v := m._Suchbegriff
	if v == nil {
		return
	}
	return *v, true
}

// OldSuchbegriff returns the old "Suchbegriff" field's value of the Artikel entity.
// If the Artikel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtikelMutation) OldSuchbegriff(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuchbegriff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuchbegriff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuchbegriff: %w", err)
	}
	return oldValue.Suchbegriff, nil
}

// ResetSuchbegriff resets all changes to the "Suchbegriff" field.
func (m *ArtikelMutation) ResetSuchbegriff() {
	m._Suchbegriff = nil
}

// SetAnzahl sets the "Anzahl" field.
func (m *ArtikelMutation) SetAnzahl(i int) {
	m._Anzahl = &i
	m.add_Anzahl = nil
}

// Anzahl returns the value of the "Anzahl" field in the mutation.
func (m *ArtikelMutation) Anzahl() (r int, exists bool) {
	v := m._Anzahl
	if v == nil {
		return
	}
	return *v, true
}

// OldAnzahl returns the old "Anzahl" field's value of the Artikel entity.
// If the Artikel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ArtikelMutation) OldAnzahl(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnzahl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnzahl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnzahl: %w", err)
	}
	return oldValue.Anzahl, nil
}

// AddAnzahl adds i to the "Anzahl" field.
func (m *ArtikelMutation) AddAnzahl(i int) {
	if m.add_Anzahl != nil {
		*m.add_Anzahl += i
	} else {
		m.add_Anzahl = &i
	}
}

// AddedAnzahl returns the value that was added to the "Anzahl" field in this mutation.
func (m *ArtikelMutation) AddedAnzahl() (r int, exists bool) {
	v := m.add_Anzahl
	if v == nil {
		return
	}
	return *v, true
}

// ResetAnzahl resets all changes to the "Anzahl" field.
func (m *ArtikelMutation) ResetAnzahl() {
	m._Anzahl = nil
	m.add_Anzahl = nil
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *ArtikelMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *ArtikelMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *ArtikelMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *ArtikelMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *ArtikelMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *ArtikelMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the ArtikelMutation builder.
func (m *ArtikelMutation) Where(ps ...predicate.Artikel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ArtikelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ArtikelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Artikel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ArtikelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ArtikelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Artikel).
func (m *ArtikelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ArtikelMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Artikelnummer != nil {
		fields = append(fields, artikel.FieldArtikelnummer)
	}
	if m._Suchbegriff != nil {
		fields = append(fields, artikel.FieldSuchbegriff)
	}
	if m._Anzahl != nil {
		fields = append(fields, artikel.FieldAnzahl)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ArtikelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case artikel.FieldArtikelnummer:
		return m.Artikelnummer()
	case artikel.FieldSuchbegriff:
		return m.Suchbegriff()
	case artikel.FieldAnzahl:
		return m.Anzahl()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ArtikelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case artikel.FieldArtikelnummer:
		return m.OldArtikelnummer(ctx)
	case artikel.FieldSuchbegriff:
		return m.OldSuchbegriff(ctx)
	case artikel.FieldAnzahl:
		return m.OldAnzahl(ctx)
	}
	return nil, fmt.Errorf("unknown Artikel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtikelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case artikel.FieldArtikelnummer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArtikelnummer(v)
		return nil
	case artikel.FieldSuchbegriff:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuchbegriff(v)
		return nil
	case artikel.FieldAnzahl:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnzahl(v)
		return nil
	}
	return fmt.Errorf("unknown Artikel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ArtikelMutation) AddedFields() []string {
	var fields []string
	if m.add_Anzahl != nil {
		fields = append(fields, artikel.FieldAnzahl)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ArtikelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case artikel.FieldAnzahl:
		return m.AddedAnzahl()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ArtikelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case artikel.FieldAnzahl:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAnzahl(v)
		return nil
	}
	return fmt.Errorf("unknown Artikel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ArtikelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ArtikelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ArtikelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Artikel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ArtikelMutation) ResetField(name string) error {
	switch name {
	case artikel.FieldArtikelnummer:
		m.ResetArtikelnummer()
		return nil
	case artikel.FieldSuchbegriff:
		m.ResetSuchbegriff()
		return nil
	case artikel.FieldAnzahl:
		m.ResetAnzahl()
		return nil
	}
	return fmt.Errorf("unknown Artikel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ArtikelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, artikel.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ArtikelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case artikel.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ArtikelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ArtikelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ArtikelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, artikel.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ArtikelMutation) EdgeCleared(name string) bool {
	switch name {
	case artikel.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ArtikelMutation) ClearEdge(name string) error {
	switch name {
	case artikel.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Artikel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ArtikelMutation) ResetEdge(name string) error {
	switch name {
	case artikel.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Artikel edge %s", name)
}

// InventurMutation represents an operation that mutates the Inventur nodes in the graph.
type InventurMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Jahr         *int
	add_Jahr      *int
	clearedFields map[string]struct{}
	_Teams        map[int]struct{}
	removed_Teams map[int]struct{}
	cleared_Teams bool
	done          bool
	oldValue      func(context.Context) (*Inventur, error)
	predicates    []predicate.Inventur
}

var _ ent.Mutation = (*InventurMutation)(nil)

// inventurOption allows management of the mutation configuration using functional options.
type inventurOption func(*InventurMutation)

// newInventurMutation creates new mutation for the Inventur entity.
func newInventurMutation(c config, op Op, opts ...inventurOption) *InventurMutation {
	m := &InventurMutation{
		config:        c,
		op:            op,
		typ:           TypeInventur,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventurID sets the ID field of the mutation.
func withInventurID(id int) inventurOption {
	return func(m *InventurMutation) {
		var (
			err   error
			once  sync.Once
			value *Inventur
		)
		m.oldValue = func(ctx context.Context) (*Inventur, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inventur.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventur sets the old Inventur of the mutation.
func withInventur(node *Inventur) inventurOption {
	return func(m *InventurMutation) {
		m.oldValue = func(context.Context) (*Inventur, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventurMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventurMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventurMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventurMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inventur.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJahr sets the "Jahr" field.
func (m *InventurMutation) SetJahr(i int) {
	m._Jahr = &i
	m.add_Jahr = nil
}

// Jahr returns the value of the "Jahr" field in the mutation.
func (m *InventurMutation) Jahr() (r int, exists bool) {
	v := m._Jahr
	if v == nil {
		return
	}
	return *v, true
}

// OldJahr returns the old "Jahr" field's value of the Inventur entity.
// If the Inventur object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventurMutation) OldJahr(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJahr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJahr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJahr: %w", err)
	}
	return oldValue.Jahr, nil
}

// AddJahr adds i to the "Jahr" field.
func (m *InventurMutation) AddJahr(i int) {
	if m.add_Jahr != nil {
		*m.add_Jahr += i
	} else {
		m.add_Jahr = &i
	}
}

// AddedJahr returns the value that was added to the "Jahr" field in this mutation.
func (m *InventurMutation) AddedJahr() (r int, exists bool) {
	v := m.add_Jahr
	if v == nil {
		return
	}
	return *v, true
}

// ResetJahr resets all changes to the "Jahr" field.
func (m *InventurMutation) ResetJahr() {
	m._Jahr = nil
	m.add_Jahr = nil
}

// AddTeamIDs adds the "Teams" edge to the Team entity by ids.
func (m *InventurMutation) AddTeamIDs(ids ...int) {
	if m._Teams == nil {
		m._Teams = make(map[int]struct{})
	}
	for i := range ids {
		m._Teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "Teams" edge to the Team entity.
func (m *InventurMutation) ClearTeams() {
	m.cleared_Teams = true
}

// TeamsCleared reports if the "Teams" edge to the Team entity was cleared.
func (m *InventurMutation) TeamsCleared() bool {
	return m.cleared_Teams
}

// RemoveTeamIDs removes the "Teams" edge to the Team entity by IDs.
func (m *InventurMutation) RemoveTeamIDs(ids ...int) {
	if m.removed_Teams == nil {
		m.removed_Teams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Teams, ids[i])
		m.removed_Teams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "Teams" edge to the Team entity.
func (m *InventurMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removed_Teams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "Teams" edge IDs in the mutation.
func (m *InventurMutation) TeamsIDs() (ids []int) {
	for id := range m._Teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "Teams" edge.
func (m *InventurMutation) ResetTeams() {
	m._Teams = nil
	m.cleared_Teams = false
	m.removed_Teams = nil
}

// Where appends a list predicates to the InventurMutation builder.
func (m *InventurMutation) Where(ps ...predicate.Inventur) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventurMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventurMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Inventur, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventurMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventurMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Inventur).
func (m *InventurMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventurMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Jahr != nil {
		fields = append(fields, inventur.FieldJahr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventurMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventur.FieldJahr:
		return m.Jahr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventurMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventur.FieldJahr:
		return m.OldJahr(ctx)
	}
	return nil, fmt.Errorf("unknown Inventur field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventurMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventur.FieldJahr:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJahr(v)
		return nil
	}
	return fmt.Errorf("unknown Inventur field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventurMutation) AddedFields() []string {
	var fields []string
	if m.add_Jahr != nil {
		fields = append(fields, inventur.FieldJahr)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventurMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inventur.FieldJahr:
		return m.AddedJahr()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventurMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inventur.FieldJahr:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJahr(v)
		return nil
	}
	return fmt.Errorf("unknown Inventur numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventurMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventurMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventurMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Inventur nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventurMutation) ResetField(name string) error {
	switch name {
	case inventur.FieldJahr:
		m.ResetJahr()
		return nil
	}
	return fmt.Errorf("unknown Inventur field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventurMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Teams != nil {
		edges = append(edges, inventur.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventurMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventur.EdgeTeams:
		ids := make([]ent.Value, 0, len(m._Teams))
		for id := range m._Teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventurMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Teams != nil {
		edges = append(edges, inventur.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventurMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inventur.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removed_Teams))
		for id := range m.removed_Teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventurMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Teams {
		edges = append(edges, inventur.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventurMutation) EdgeCleared(name string) bool {
	switch name {
	case inventur.EdgeTeams:
		return m.cleared_Teams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventurMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Inventur unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventurMutation) ResetEdge(name string) error {
	switch name {
	case inventur.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown Inventur edge %s", name)
}

// LieferantMutation represents an operation that mutates the Lieferant nodes in the graph.
type LieferantMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	_Firma                  *string
	_Kundennummer           *string
	_Webseite               *string
	clearedFields           map[string]struct{}
	_Ansprechpartner        map[int]struct{}
	removed_Ansprechpartner map[int]struct{}
	cleared_Ansprechpartner bool
	done                    bool
	oldValue                func(context.Context) (*Lieferant, error)
	predicates              []predicate.Lieferant
}

var _ ent.Mutation = (*LieferantMutation)(nil)

// lieferantOption allows management of the mutation configuration using functional options.
type lieferantOption func(*LieferantMutation)

// newLieferantMutation creates new mutation for the Lieferant entity.
func newLieferantMutation(c config, op Op, opts ...lieferantOption) *LieferantMutation {
	m := &LieferantMutation{
		config:        c,
		op:            op,
		typ:           TypeLieferant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLieferantID sets the ID field of the mutation.
func withLieferantID(id int) lieferantOption {
	return func(m *LieferantMutation) {
		var (
			err   error
			once  sync.Once
			value *Lieferant
		)
		m.oldValue = func(ctx context.Context) (*Lieferant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lieferant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLieferant sets the old Lieferant of the mutation.
func withLieferant(node *Lieferant) lieferantOption {
	return func(m *LieferantMutation) {
		m.oldValue = func(context.Context) (*Lieferant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LieferantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LieferantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LieferantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LieferantMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lieferant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirma sets the "Firma" field.
func (m *LieferantMutation) SetFirma(s string) {
	m._Firma = &s
}

// Firma returns the value of the "Firma" field in the mutation.
func (m *LieferantMutation) Firma() (r string, exists bool) {
	v := m._Firma
	if v == nil {
		return
	}
	return *v, true
}

// OldFirma returns the old "Firma" field's value of the Lieferant entity.
// If the Lieferant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LieferantMutation) OldFirma(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirma is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirma requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirma: %w", err)
	}
	return oldValue.Firma, nil
}

// ResetFirma resets all changes to the "Firma" field.
func (m *LieferantMutation) ResetFirma() {
	m._Firma = nil
}

// SetKundennummer sets the "Kundennummer" field.
func (m *LieferantMutation) SetKundennummer(s string) {
	m._Kundennummer = &s
}

// Kundennummer returns the value of the "Kundennummer" field in the mutation.
func (m *LieferantMutation) Kundennummer() (r string, exists bool) {
	v := m._Kundennummer
	if v == nil {
		return
	}
	return *v, true
}

// OldKundennummer returns the old "Kundennummer" field's value of the Lieferant entity.
// If the Lieferant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LieferantMutation) OldKundennummer(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKundennummer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKundennummer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKundennummer: %w", err)
	}
	return oldValue.Kundennummer, nil
}

// ClearKundennummer clears the value of the "Kundennummer" field.
func (m *LieferantMutation) ClearKundennummer() {
	m._Kundennummer = nil
	m.clearedFields[lieferant.FieldKundennummer] = struct{}{}
}

// KundennummerCleared returns if the "Kundennummer" field was cleared in this mutation.
func (m *LieferantMutation) KundennummerCleared() bool {
	_, ok := m.clearedFields[lieferant.FieldKundennummer]
	return ok
}

// ResetKundennummer resets all changes to the "Kundennummer" field.
func (m *LieferantMutation) ResetKundennummer() {
	m._Kundennummer = nil
	delete(m.clearedFields, lieferant.FieldKundennummer)
}

// SetWebseite sets the "Webseite" field.
func (m *LieferantMutation) SetWebseite(s string) {
	m._Webseite = &s
}

// Webseite returns the value of the "Webseite" field in the mutation.
func (m *LieferantMutation) Webseite() (r string, exists bool) {
	v := m._Webseite
	if v == nil {
		return
	}
	return *v, true
}

// OldWebseite returns the old "Webseite" field's value of the Lieferant entity.
// If the Lieferant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LieferantMutation) OldWebseite(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebseite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebseite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebseite: %w", err)
	}
	return oldValue.Webseite, nil
}

// ClearWebseite clears the value of the "Webseite" field.
func (m *LieferantMutation) ClearWebseite() {
	m._Webseite = nil
	m.clearedFields[lieferant.FieldWebseite] = struct{}{}
}

// WebseiteCleared returns if the "Webseite" field was cleared in this mutation.
func (m *LieferantMutation) WebseiteCleared() bool {
	_, ok := m.clearedFields[lieferant.FieldWebseite]
	return ok
}

// ResetWebseite resets all changes to the "Webseite" field.
func (m *LieferantMutation) ResetWebseite() {
	m._Webseite = nil
	delete(m.clearedFields, lieferant.FieldWebseite)
}

// AddAnsprechpartnerIDs adds the "Ansprechpartner" edge to the Ansprechpartner entity by ids.
func (m *LieferantMutation) AddAnsprechpartnerIDs(ids ...int) {
	if m._Ansprechpartner == nil {
		m._Ansprechpartner = make(map[int]struct{})
	}
	for i := range ids {
		m._Ansprechpartner[ids[i]] = struct{}{}
	}
}

// ClearAnsprechpartner clears the "Ansprechpartner" edge to the Ansprechpartner entity.
func (m *LieferantMutation) ClearAnsprechpartner() {
	m.cleared_Ansprechpartner = true
}

// AnsprechpartnerCleared reports if the "Ansprechpartner" edge to the Ansprechpartner entity was cleared.
func (m *LieferantMutation) AnsprechpartnerCleared() bool {
	return m.cleared_Ansprechpartner
}

// RemoveAnsprechpartnerIDs removes the "Ansprechpartner" edge to the Ansprechpartner entity by IDs.
func (m *LieferantMutation) RemoveAnsprechpartnerIDs(ids ...int) {
	if m.removed_Ansprechpartner == nil {
		m.removed_Ansprechpartner = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Ansprechpartner, ids[i])
		m.removed_Ansprechpartner[ids[i]] = struct{}{}
	}
}

// RemovedAnsprechpartner returns the removed IDs of the "Ansprechpartner" edge to the Ansprechpartner entity.
func (m *LieferantMutation) RemovedAnsprechpartnerIDs() (ids []int) {
	for id := range m.removed_Ansprechpartner {
		ids = append(ids, id)
	}
	return
}

// AnsprechpartnerIDs returns the "Ansprechpartner" edge IDs in the mutation.
func (m *LieferantMutation) AnsprechpartnerIDs() (ids []int) {
	for id := range m._Ansprechpartner {
		ids = append(ids, id)
	}
	return
}

// ResetAnsprechpartner resets all changes to the "Ansprechpartner" edge.
func (m *LieferantMutation) ResetAnsprechpartner() {
	m._Ansprechpartner = nil
	m.cleared_Ansprechpartner = false
	m.removed_Ansprechpartner = nil
}

// Where appends a list predicates to the LieferantMutation builder.
func (m *LieferantMutation) Where(ps ...predicate.Lieferant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LieferantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LieferantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lieferant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LieferantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LieferantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lieferant).
func (m *LieferantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LieferantMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Firma != nil {
		fields = append(fields, lieferant.FieldFirma)
	}
	if m._Kundennummer != nil {
		fields = append(fields, lieferant.FieldKundennummer)
	}
	if m._Webseite != nil {
		fields = append(fields, lieferant.FieldWebseite)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LieferantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lieferant.FieldFirma:
		return m.Firma()
	case lieferant.FieldKundennummer:
		return m.Kundennummer()
	case lieferant.FieldWebseite:
		return m.Webseite()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LieferantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lieferant.FieldFirma:
		return m.OldFirma(ctx)
	case lieferant.FieldKundennummer:
		return m.OldKundennummer(ctx)
	case lieferant.FieldWebseite:
		return m.OldWebseite(ctx)
	}
	return nil, fmt.Errorf("unknown Lieferant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LieferantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lieferant.FieldFirma:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirma(v)
		return nil
	case lieferant.FieldKundennummer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKundennummer(v)
		return nil
	case lieferant.FieldWebseite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebseite(v)
		return nil
	}
	return fmt.Errorf("unknown Lieferant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LieferantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LieferantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LieferantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Lieferant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LieferantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lieferant.FieldKundennummer) {
		fields = append(fields, lieferant.FieldKundennummer)
	}
	if m.FieldCleared(lieferant.FieldWebseite) {
		fields = append(fields, lieferant.FieldWebseite)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LieferantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LieferantMutation) ClearField(name string) error {
	switch name {
	case lieferant.FieldKundennummer:
		m.ClearKundennummer()
		return nil
	case lieferant.FieldWebseite:
		m.ClearWebseite()
		return nil
	}
	return fmt.Errorf("unknown Lieferant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LieferantMutation) ResetField(name string) error {
	switch name {
	case lieferant.FieldFirma:
		m.ResetFirma()
		return nil
	case lieferant.FieldKundennummer:
		m.ResetKundennummer()
		return nil
	case lieferant.FieldWebseite:
		m.ResetWebseite()
		return nil
	}
	return fmt.Errorf("unknown Lieferant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LieferantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Ansprechpartner != nil {
		edges = append(edges, lieferant.EdgeAnsprechpartner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LieferantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lieferant.EdgeAnsprechpartner:
		ids := make([]ent.Value, 0, len(m._Ansprechpartner))
		for id := range m._Ansprechpartner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LieferantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Ansprechpartner != nil {
		edges = append(edges, lieferant.EdgeAnsprechpartner)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LieferantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case lieferant.EdgeAnsprechpartner:
		ids := make([]ent.Value, 0, len(m.removed_Ansprechpartner))
		for id := range m.removed_Ansprechpartner {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LieferantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Ansprechpartner {
		edges = append(edges, lieferant.EdgeAnsprechpartner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LieferantMutation) EdgeCleared(name string) bool {
	switch name {
	case lieferant.EdgeAnsprechpartner:
		return m.cleared_Ansprechpartner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LieferantMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Lieferant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LieferantMutation) ResetEdge(name string) error {
	switch name {
	case lieferant.EdgeAnsprechpartner:
		m.ResetAnsprechpartner()
		return nil
	}
	return fmt.Errorf("unknown Lieferant edge %s", name)
}

// MitarbeiterMutation represents an operation that mutates the Mitarbeiter nodes in the graph.
type MitarbeiterMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_Name               *string
	_Short              *string
	_Gruppenwahl        *string
	_InternTelefon1     *string
	_InternTelefon2     *string
	_FestnetzPrivat     *string
	_FestnetzAlternativ *string
	_HomeOffice         *string
	_MobilBusiness      *string
	_MobilPrivat        *string
	_Email              *string
	_Azubi              *bool
	_Geburtstag         *time.Time
	_Paypal             *bool
	_Abonniert          *bool
	_Geld               *string
	_Pfand              *string
	_Dinge              *string
	_Abgeschickt        *time.Time
	_Bild1              *string
	_Bild2              *string
	_Bild3              *string
	_Bild1Date          *time.Time
	_Bild2Date          *time.Time
	_Bild3Date          *time.Time
	clearedFields       map[string]struct{}
	mitarbeiter         *int
	clearedmitarbeiter  bool
	done                bool
	oldValue            func(context.Context) (*Mitarbeiter, error)
	predicates          []predicate.Mitarbeiter
}

var _ ent.Mutation = (*MitarbeiterMutation)(nil)

// mitarbeiterOption allows management of the mutation configuration using functional options.
type mitarbeiterOption func(*MitarbeiterMutation)

// newMitarbeiterMutation creates new mutation for the Mitarbeiter entity.
func newMitarbeiterMutation(c config, op Op, opts ...mitarbeiterOption) *MitarbeiterMutation {
	m := &MitarbeiterMutation{
		config:        c,
		op:            op,
		typ:           TypeMitarbeiter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMitarbeiterID sets the ID field of the mutation.
func withMitarbeiterID(id int) mitarbeiterOption {
	return func(m *MitarbeiterMutation) {
		var (
			err   error
			once  sync.Once
			value *Mitarbeiter
		)
		m.oldValue = func(ctx context.Context) (*Mitarbeiter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mitarbeiter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMitarbeiter sets the old Mitarbeiter of the mutation.
func withMitarbeiter(node *Mitarbeiter) mitarbeiterOption {
	return func(m *MitarbeiterMutation) {
		m.oldValue = func(context.Context) (*Mitarbeiter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MitarbeiterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MitarbeiterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MitarbeiterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MitarbeiterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mitarbeiter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *MitarbeiterMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *MitarbeiterMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *MitarbeiterMutation) ResetName() {
	m._Name = nil
}

// SetShort sets the "Short" field.
func (m *MitarbeiterMutation) SetShort(s string) {
	m._Short = &s
}

// Short returns the value of the "Short" field in the mutation.
func (m *MitarbeiterMutation) Short() (r string, exists bool) {
	v := m._Short
	if v == nil {
		return
	}
	return *v, true
}

// OldShort returns the old "Short" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldShort(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShort: %w", err)
	}
	return oldValue.Short, nil
}

// ClearShort clears the value of the "Short" field.
func (m *MitarbeiterMutation) ClearShort() {
	m._Short = nil
	m.clearedFields[mitarbeiter.FieldShort] = struct{}{}
}

// ShortCleared returns if the "Short" field was cleared in this mutation.
func (m *MitarbeiterMutation) ShortCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldShort]
	return ok
}

// ResetShort resets all changes to the "Short" field.
func (m *MitarbeiterMutation) ResetShort() {
	m._Short = nil
	delete(m.clearedFields, mitarbeiter.FieldShort)
}

// SetGruppenwahl sets the "Gruppenwahl" field.
func (m *MitarbeiterMutation) SetGruppenwahl(s string) {
	m._Gruppenwahl = &s
}

// Gruppenwahl returns the value of the "Gruppenwahl" field in the mutation.
func (m *MitarbeiterMutation) Gruppenwahl() (r string, exists bool) {
	v := m._Gruppenwahl
	if v == nil {
		return
	}
	return *v, true
}

// OldGruppenwahl returns the old "Gruppenwahl" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldGruppenwahl(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGruppenwahl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGruppenwahl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGruppenwahl: %w", err)
	}
	return oldValue.Gruppenwahl, nil
}

// ClearGruppenwahl clears the value of the "Gruppenwahl" field.
func (m *MitarbeiterMutation) ClearGruppenwahl() {
	m._Gruppenwahl = nil
	m.clearedFields[mitarbeiter.FieldGruppenwahl] = struct{}{}
}

// GruppenwahlCleared returns if the "Gruppenwahl" field was cleared in this mutation.
func (m *MitarbeiterMutation) GruppenwahlCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldGruppenwahl]
	return ok
}

// ResetGruppenwahl resets all changes to the "Gruppenwahl" field.
func (m *MitarbeiterMutation) ResetGruppenwahl() {
	m._Gruppenwahl = nil
	delete(m.clearedFields, mitarbeiter.FieldGruppenwahl)
}

// SetInternTelefon1 sets the "InternTelefon1" field.
func (m *MitarbeiterMutation) SetInternTelefon1(s string) {
	m._InternTelefon1 = &s
}

// InternTelefon1 returns the value of the "InternTelefon1" field in the mutation.
func (m *MitarbeiterMutation) InternTelefon1() (r string, exists bool) {
	v := m._InternTelefon1
	if v == nil {
		return
	}
	return *v, true
}

// OldInternTelefon1 returns the old "InternTelefon1" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldInternTelefon1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternTelefon1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternTelefon1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternTelefon1: %w", err)
	}
	return oldValue.InternTelefon1, nil
}

// ClearInternTelefon1 clears the value of the "InternTelefon1" field.
func (m *MitarbeiterMutation) ClearInternTelefon1() {
	m._InternTelefon1 = nil
	m.clearedFields[mitarbeiter.FieldInternTelefon1] = struct{}{}
}

// InternTelefon1Cleared returns if the "InternTelefon1" field was cleared in this mutation.
func (m *MitarbeiterMutation) InternTelefon1Cleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldInternTelefon1]
	return ok
}

// ResetInternTelefon1 resets all changes to the "InternTelefon1" field.
func (m *MitarbeiterMutation) ResetInternTelefon1() {
	m._InternTelefon1 = nil
	delete(m.clearedFields, mitarbeiter.FieldInternTelefon1)
}

// SetInternTelefon2 sets the "InternTelefon2" field.
func (m *MitarbeiterMutation) SetInternTelefon2(s string) {
	m._InternTelefon2 = &s
}

// InternTelefon2 returns the value of the "InternTelefon2" field in the mutation.
func (m *MitarbeiterMutation) InternTelefon2() (r string, exists bool) {
	v := m._InternTelefon2
	if v == nil {
		return
	}
	return *v, true
}

// OldInternTelefon2 returns the old "InternTelefon2" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldInternTelefon2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternTelefon2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternTelefon2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternTelefon2: %w", err)
	}
	return oldValue.InternTelefon2, nil
}

// ClearInternTelefon2 clears the value of the "InternTelefon2" field.
func (m *MitarbeiterMutation) ClearInternTelefon2() {
	m._InternTelefon2 = nil
	m.clearedFields[mitarbeiter.FieldInternTelefon2] = struct{}{}
}

// InternTelefon2Cleared returns if the "InternTelefon2" field was cleared in this mutation.
func (m *MitarbeiterMutation) InternTelefon2Cleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldInternTelefon2]
	return ok
}

// ResetInternTelefon2 resets all changes to the "InternTelefon2" field.
func (m *MitarbeiterMutation) ResetInternTelefon2() {
	m._InternTelefon2 = nil
	delete(m.clearedFields, mitarbeiter.FieldInternTelefon2)
}

// SetFestnetzPrivat sets the "FestnetzPrivat" field.
func (m *MitarbeiterMutation) SetFestnetzPrivat(s string) {
	m._FestnetzPrivat = &s
}

// FestnetzPrivat returns the value of the "FestnetzPrivat" field in the mutation.
func (m *MitarbeiterMutation) FestnetzPrivat() (r string, exists bool) {
	v := m._FestnetzPrivat
	if v == nil {
		return
	}
	return *v, true
}

// OldFestnetzPrivat returns the old "FestnetzPrivat" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldFestnetzPrivat(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFestnetzPrivat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFestnetzPrivat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFestnetzPrivat: %w", err)
	}
	return oldValue.FestnetzPrivat, nil
}

// ClearFestnetzPrivat clears the value of the "FestnetzPrivat" field.
func (m *MitarbeiterMutation) ClearFestnetzPrivat() {
	m._FestnetzPrivat = nil
	m.clearedFields[mitarbeiter.FieldFestnetzPrivat] = struct{}{}
}

// FestnetzPrivatCleared returns if the "FestnetzPrivat" field was cleared in this mutation.
func (m *MitarbeiterMutation) FestnetzPrivatCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldFestnetzPrivat]
	return ok
}

// ResetFestnetzPrivat resets all changes to the "FestnetzPrivat" field.
func (m *MitarbeiterMutation) ResetFestnetzPrivat() {
	m._FestnetzPrivat = nil
	delete(m.clearedFields, mitarbeiter.FieldFestnetzPrivat)
}

// SetFestnetzAlternativ sets the "FestnetzAlternativ" field.
func (m *MitarbeiterMutation) SetFestnetzAlternativ(s string) {
	m._FestnetzAlternativ = &s
}

// FestnetzAlternativ returns the value of the "FestnetzAlternativ" field in the mutation.
func (m *MitarbeiterMutation) FestnetzAlternativ() (r string, exists bool) {
	v := m._FestnetzAlternativ
	if v == nil {
		return
	}
	return *v, true
}

// OldFestnetzAlternativ returns the old "FestnetzAlternativ" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldFestnetzAlternativ(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFestnetzAlternativ is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFestnetzAlternativ requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFestnetzAlternativ: %w", err)
	}
	return oldValue.FestnetzAlternativ, nil
}

// ClearFestnetzAlternativ clears the value of the "FestnetzAlternativ" field.
func (m *MitarbeiterMutation) ClearFestnetzAlternativ() {
	m._FestnetzAlternativ = nil
	m.clearedFields[mitarbeiter.FieldFestnetzAlternativ] = struct{}{}
}

// FestnetzAlternativCleared returns if the "FestnetzAlternativ" field was cleared in this mutation.
func (m *MitarbeiterMutation) FestnetzAlternativCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldFestnetzAlternativ]
	return ok
}

// ResetFestnetzAlternativ resets all changes to the "FestnetzAlternativ" field.
func (m *MitarbeiterMutation) ResetFestnetzAlternativ() {
	m._FestnetzAlternativ = nil
	delete(m.clearedFields, mitarbeiter.FieldFestnetzAlternativ)
}

// SetHomeOffice sets the "HomeOffice" field.
func (m *MitarbeiterMutation) SetHomeOffice(s string) {
	m._HomeOffice = &s
}

// HomeOffice returns the value of the "HomeOffice" field in the mutation.
func (m *MitarbeiterMutation) HomeOffice() (r string, exists bool) {
	v := m._HomeOffice
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeOffice returns the old "HomeOffice" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldHomeOffice(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeOffice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeOffice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeOffice: %w", err)
	}
	return oldValue.HomeOffice, nil
}

// ClearHomeOffice clears the value of the "HomeOffice" field.
func (m *MitarbeiterMutation) ClearHomeOffice() {
	m._HomeOffice = nil
	m.clearedFields[mitarbeiter.FieldHomeOffice] = struct{}{}
}

// HomeOfficeCleared returns if the "HomeOffice" field was cleared in this mutation.
func (m *MitarbeiterMutation) HomeOfficeCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldHomeOffice]
	return ok
}

// ResetHomeOffice resets all changes to the "HomeOffice" field.
func (m *MitarbeiterMutation) ResetHomeOffice() {
	m._HomeOffice = nil
	delete(m.clearedFields, mitarbeiter.FieldHomeOffice)
}

// SetMobilBusiness sets the "MobilBusiness" field.
func (m *MitarbeiterMutation) SetMobilBusiness(s string) {
	m._MobilBusiness = &s
}

// MobilBusiness returns the value of the "MobilBusiness" field in the mutation.
func (m *MitarbeiterMutation) MobilBusiness() (r string, exists bool) {
	v := m._MobilBusiness
	if v == nil {
		return
	}
	return *v, true
}

// OldMobilBusiness returns the old "MobilBusiness" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldMobilBusiness(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobilBusiness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobilBusiness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobilBusiness: %w", err)
	}
	return oldValue.MobilBusiness, nil
}

// ClearMobilBusiness clears the value of the "MobilBusiness" field.
func (m *MitarbeiterMutation) ClearMobilBusiness() {
	m._MobilBusiness = nil
	m.clearedFields[mitarbeiter.FieldMobilBusiness] = struct{}{}
}

// MobilBusinessCleared returns if the "MobilBusiness" field was cleared in this mutation.
func (m *MitarbeiterMutation) MobilBusinessCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldMobilBusiness]
	return ok
}

// ResetMobilBusiness resets all changes to the "MobilBusiness" field.
func (m *MitarbeiterMutation) ResetMobilBusiness() {
	m._MobilBusiness = nil
	delete(m.clearedFields, mitarbeiter.FieldMobilBusiness)
}

// SetMobilPrivat sets the "MobilPrivat" field.
func (m *MitarbeiterMutation) SetMobilPrivat(s string) {
	m._MobilPrivat = &s
}

// MobilPrivat returns the value of the "MobilPrivat" field in the mutation.
func (m *MitarbeiterMutation) MobilPrivat() (r string, exists bool) {
	v := m._MobilPrivat
	if v == nil {
		return
	}
	return *v, true
}

// OldMobilPrivat returns the old "MobilPrivat" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldMobilPrivat(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobilPrivat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobilPrivat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobilPrivat: %w", err)
	}
	return oldValue.MobilPrivat, nil
}

// ClearMobilPrivat clears the value of the "MobilPrivat" field.
func (m *MitarbeiterMutation) ClearMobilPrivat() {
	m._MobilPrivat = nil
	m.clearedFields[mitarbeiter.FieldMobilPrivat] = struct{}{}
}

// MobilPrivatCleared returns if the "MobilPrivat" field was cleared in this mutation.
func (m *MitarbeiterMutation) MobilPrivatCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldMobilPrivat]
	return ok
}

// ResetMobilPrivat resets all changes to the "MobilPrivat" field.
func (m *MitarbeiterMutation) ResetMobilPrivat() {
	m._MobilPrivat = nil
	delete(m.clearedFields, mitarbeiter.FieldMobilPrivat)
}

// SetEmail sets the "Email" field.
func (m *MitarbeiterMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *MitarbeiterMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *MitarbeiterMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[mitarbeiter.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *MitarbeiterMutation) EmailCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *MitarbeiterMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, mitarbeiter.FieldEmail)
}

// SetAzubi sets the "Azubi" field.
func (m *MitarbeiterMutation) SetAzubi(b bool) {
	m._Azubi = &b
}

// Azubi returns the value of the "Azubi" field in the mutation.
func (m *MitarbeiterMutation) Azubi() (r bool, exists bool) {
	v := m._Azubi
	if v == nil {
		return
	}
	return *v, true
}

// OldAzubi returns the old "Azubi" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldAzubi(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAzubi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAzubi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAzubi: %w", err)
	}
	return oldValue.Azubi, nil
}

// ResetAzubi resets all changes to the "Azubi" field.
func (m *MitarbeiterMutation) ResetAzubi() {
	m._Azubi = nil
}

// SetGeburtstag sets the "Geburtstag" field.
func (m *MitarbeiterMutation) SetGeburtstag(t time.Time) {
	m._Geburtstag = &t
}

// Geburtstag returns the value of the "Geburtstag" field in the mutation.
func (m *MitarbeiterMutation) Geburtstag() (r time.Time, exists bool) {
	v := m._Geburtstag
	if v == nil {
		return
	}
	return *v, true
}

// OldGeburtstag returns the old "Geburtstag" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldGeburtstag(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeburtstag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeburtstag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeburtstag: %w", err)
	}
	return oldValue.Geburtstag, nil
}

// ClearGeburtstag clears the value of the "Geburtstag" field.
func (m *MitarbeiterMutation) ClearGeburtstag() {
	m._Geburtstag = nil
	m.clearedFields[mitarbeiter.FieldGeburtstag] = struct{}{}
}

// GeburtstagCleared returns if the "Geburtstag" field was cleared in this mutation.
func (m *MitarbeiterMutation) GeburtstagCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldGeburtstag]
	return ok
}

// ResetGeburtstag resets all changes to the "Geburtstag" field.
func (m *MitarbeiterMutation) ResetGeburtstag() {
	m._Geburtstag = nil
	delete(m.clearedFields, mitarbeiter.FieldGeburtstag)
}

// SetPaypal sets the "Paypal" field.
func (m *MitarbeiterMutation) SetPaypal(b bool) {
	m._Paypal = &b
}

// Paypal returns the value of the "Paypal" field in the mutation.
func (m *MitarbeiterMutation) Paypal() (r bool, exists bool) {
	v := m._Paypal
	if v == nil {
		return
	}
	return *v, true
}

// OldPaypal returns the old "Paypal" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldPaypal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaypal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaypal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaypal: %w", err)
	}
	return oldValue.Paypal, nil
}

// ResetPaypal resets all changes to the "Paypal" field.
func (m *MitarbeiterMutation) ResetPaypal() {
	m._Paypal = nil
}

// SetAbonniert sets the "Abonniert" field.
func (m *MitarbeiterMutation) SetAbonniert(b bool) {
	m._Abonniert = &b
}

// Abonniert returns the value of the "Abonniert" field in the mutation.
func (m *MitarbeiterMutation) Abonniert() (r bool, exists bool) {
	v := m._Abonniert
	if v == nil {
		return
	}
	return *v, true
}

// OldAbonniert returns the old "Abonniert" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldAbonniert(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbonniert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbonniert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbonniert: %w", err)
	}
	return oldValue.Abonniert, nil
}

// ResetAbonniert resets all changes to the "Abonniert" field.
func (m *MitarbeiterMutation) ResetAbonniert() {
	m._Abonniert = nil
}

// SetGeld sets the "Geld" field.
func (m *MitarbeiterMutation) SetGeld(s string) {
	m._Geld = &s
}

// Geld returns the value of the "Geld" field in the mutation.
func (m *MitarbeiterMutation) Geld() (r string, exists bool) {
	v := m._Geld
	if v == nil {
		return
	}
	return *v, true
}

// OldGeld returns the old "Geld" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldGeld(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeld: %w", err)
	}
	return oldValue.Geld, nil
}

// ClearGeld clears the value of the "Geld" field.
func (m *MitarbeiterMutation) ClearGeld() {
	m._Geld = nil
	m.clearedFields[mitarbeiter.FieldGeld] = struct{}{}
}

// GeldCleared returns if the "Geld" field was cleared in this mutation.
func (m *MitarbeiterMutation) GeldCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldGeld]
	return ok
}

// ResetGeld resets all changes to the "Geld" field.
func (m *MitarbeiterMutation) ResetGeld() {
	m._Geld = nil
	delete(m.clearedFields, mitarbeiter.FieldGeld)
}

// SetPfand sets the "Pfand" field.
func (m *MitarbeiterMutation) SetPfand(s string) {
	m._Pfand = &s
}

// Pfand returns the value of the "Pfand" field in the mutation.
func (m *MitarbeiterMutation) Pfand() (r string, exists bool) {
	v := m._Pfand
	if v == nil {
		return
	}
	return *v, true
}

// OldPfand returns the old "Pfand" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldPfand(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPfand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPfand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPfand: %w", err)
	}
	return oldValue.Pfand, nil
}

// ClearPfand clears the value of the "Pfand" field.
func (m *MitarbeiterMutation) ClearPfand() {
	m._Pfand = nil
	m.clearedFields[mitarbeiter.FieldPfand] = struct{}{}
}

// PfandCleared returns if the "Pfand" field was cleared in this mutation.
func (m *MitarbeiterMutation) PfandCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldPfand]
	return ok
}

// ResetPfand resets all changes to the "Pfand" field.
func (m *MitarbeiterMutation) ResetPfand() {
	m._Pfand = nil
	delete(m.clearedFields, mitarbeiter.FieldPfand)
}

// SetDinge sets the "Dinge" field.
func (m *MitarbeiterMutation) SetDinge(s string) {
	m._Dinge = &s
}

// Dinge returns the value of the "Dinge" field in the mutation.
func (m *MitarbeiterMutation) Dinge() (r string, exists bool) {
	v := m._Dinge
	if v == nil {
		return
	}
	return *v, true
}

// OldDinge returns the old "Dinge" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldDinge(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDinge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDinge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDinge: %w", err)
	}
	return oldValue.Dinge, nil
}

// ClearDinge clears the value of the "Dinge" field.
func (m *MitarbeiterMutation) ClearDinge() {
	m._Dinge = nil
	m.clearedFields[mitarbeiter.FieldDinge] = struct{}{}
}

// DingeCleared returns if the "Dinge" field was cleared in this mutation.
func (m *MitarbeiterMutation) DingeCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldDinge]
	return ok
}

// ResetDinge resets all changes to the "Dinge" field.
func (m *MitarbeiterMutation) ResetDinge() {
	m._Dinge = nil
	delete(m.clearedFields, mitarbeiter.FieldDinge)
}

// SetAbgeschickt sets the "Abgeschickt" field.
func (m *MitarbeiterMutation) SetAbgeschickt(t time.Time) {
	m._Abgeschickt = &t
}

// Abgeschickt returns the value of the "Abgeschickt" field in the mutation.
func (m *MitarbeiterMutation) Abgeschickt() (r time.Time, exists bool) {
	v := m._Abgeschickt
	if v == nil {
		return
	}
	return *v, true
}

// OldAbgeschickt returns the old "Abgeschickt" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldAbgeschickt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbgeschickt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbgeschickt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbgeschickt: %w", err)
	}
	return oldValue.Abgeschickt, nil
}

// ClearAbgeschickt clears the value of the "Abgeschickt" field.
func (m *MitarbeiterMutation) ClearAbgeschickt() {
	m._Abgeschickt = nil
	m.clearedFields[mitarbeiter.FieldAbgeschickt] = struct{}{}
}

// AbgeschicktCleared returns if the "Abgeschickt" field was cleared in this mutation.
func (m *MitarbeiterMutation) AbgeschicktCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldAbgeschickt]
	return ok
}

// ResetAbgeschickt resets all changes to the "Abgeschickt" field.
func (m *MitarbeiterMutation) ResetAbgeschickt() {
	m._Abgeschickt = nil
	delete(m.clearedFields, mitarbeiter.FieldAbgeschickt)
}

// SetBild1 sets the "Bild1" field.
func (m *MitarbeiterMutation) SetBild1(s string) {
	m._Bild1 = &s
}

// Bild1 returns the value of the "Bild1" field in the mutation.
func (m *MitarbeiterMutation) Bild1() (r string, exists bool) {
	v := m._Bild1
	if v == nil {
		return
	}
	return *v, true
}

// OldBild1 returns the old "Bild1" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldBild1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBild1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBild1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBild1: %w", err)
	}
	return oldValue.Bild1, nil
}

// ClearBild1 clears the value of the "Bild1" field.
func (m *MitarbeiterMutation) ClearBild1() {
	m._Bild1 = nil
	m.clearedFields[mitarbeiter.FieldBild1] = struct{}{}
}

// Bild1Cleared returns if the "Bild1" field was cleared in this mutation.
func (m *MitarbeiterMutation) Bild1Cleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldBild1]
	return ok
}

// ResetBild1 resets all changes to the "Bild1" field.
func (m *MitarbeiterMutation) ResetBild1() {
	m._Bild1 = nil
	delete(m.clearedFields, mitarbeiter.FieldBild1)
}

// SetBild2 sets the "Bild2" field.
func (m *MitarbeiterMutation) SetBild2(s string) {
	m._Bild2 = &s
}

// Bild2 returns the value of the "Bild2" field in the mutation.
func (m *MitarbeiterMutation) Bild2() (r string, exists bool) {
	v := m._Bild2
	if v == nil {
		return
	}
	return *v, true
}

// OldBild2 returns the old "Bild2" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldBild2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBild2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBild2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBild2: %w", err)
	}
	return oldValue.Bild2, nil
}

// ClearBild2 clears the value of the "Bild2" field.
func (m *MitarbeiterMutation) ClearBild2() {
	m._Bild2 = nil
	m.clearedFields[mitarbeiter.FieldBild2] = struct{}{}
}

// Bild2Cleared returns if the "Bild2" field was cleared in this mutation.
func (m *MitarbeiterMutation) Bild2Cleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldBild2]
	return ok
}

// ResetBild2 resets all changes to the "Bild2" field.
func (m *MitarbeiterMutation) ResetBild2() {
	m._Bild2 = nil
	delete(m.clearedFields, mitarbeiter.FieldBild2)
}

// SetBild3 sets the "Bild3" field.
func (m *MitarbeiterMutation) SetBild3(s string) {
	m._Bild3 = &s
}

// Bild3 returns the value of the "Bild3" field in the mutation.
func (m *MitarbeiterMutation) Bild3() (r string, exists bool) {
	v := m._Bild3
	if v == nil {
		return
	}
	return *v, true
}

// OldBild3 returns the old "Bild3" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldBild3(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBild3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBild3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBild3: %w", err)
	}
	return oldValue.Bild3, nil
}

// ClearBild3 clears the value of the "Bild3" field.
func (m *MitarbeiterMutation) ClearBild3() {
	m._Bild3 = nil
	m.clearedFields[mitarbeiter.FieldBild3] = struct{}{}
}

// Bild3Cleared returns if the "Bild3" field was cleared in this mutation.
func (m *MitarbeiterMutation) Bild3Cleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldBild3]
	return ok
}

// ResetBild3 resets all changes to the "Bild3" field.
func (m *MitarbeiterMutation) ResetBild3() {
	m._Bild3 = nil
	delete(m.clearedFields, mitarbeiter.FieldBild3)
}

// SetBild1Date sets the "Bild1Date" field.
func (m *MitarbeiterMutation) SetBild1Date(t time.Time) {
	m._Bild1Date = &t
}

// Bild1Date returns the value of the "Bild1Date" field in the mutation.
func (m *MitarbeiterMutation) Bild1Date() (r time.Time, exists bool) {
	v := m._Bild1Date
	if v == nil {
		return
	}
	return *v, true
}

// OldBild1Date returns the old "Bild1Date" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldBild1Date(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBild1Date is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBild1Date requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBild1Date: %w", err)
	}
	return oldValue.Bild1Date, nil
}

// ClearBild1Date clears the value of the "Bild1Date" field.
func (m *MitarbeiterMutation) ClearBild1Date() {
	m._Bild1Date = nil
	m.clearedFields[mitarbeiter.FieldBild1Date] = struct{}{}
}

// Bild1DateCleared returns if the "Bild1Date" field was cleared in this mutation.
func (m *MitarbeiterMutation) Bild1DateCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldBild1Date]
	return ok
}

// ResetBild1Date resets all changes to the "Bild1Date" field.
func (m *MitarbeiterMutation) ResetBild1Date() {
	m._Bild1Date = nil
	delete(m.clearedFields, mitarbeiter.FieldBild1Date)
}

// SetBild2Date sets the "Bild2Date" field.
func (m *MitarbeiterMutation) SetBild2Date(t time.Time) {
	m._Bild2Date = &t
}

// Bild2Date returns the value of the "Bild2Date" field in the mutation.
func (m *MitarbeiterMutation) Bild2Date() (r time.Time, exists bool) {
	v := m._Bild2Date
	if v == nil {
		return
	}
	return *v, true
}

// OldBild2Date returns the old "Bild2Date" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldBild2Date(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBild2Date is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBild2Date requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBild2Date: %w", err)
	}
	return oldValue.Bild2Date, nil
}

// ClearBild2Date clears the value of the "Bild2Date" field.
func (m *MitarbeiterMutation) ClearBild2Date() {
	m._Bild2Date = nil
	m.clearedFields[mitarbeiter.FieldBild2Date] = struct{}{}
}

// Bild2DateCleared returns if the "Bild2Date" field was cleared in this mutation.
func (m *MitarbeiterMutation) Bild2DateCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldBild2Date]
	return ok
}

// ResetBild2Date resets all changes to the "Bild2Date" field.
func (m *MitarbeiterMutation) ResetBild2Date() {
	m._Bild2Date = nil
	delete(m.clearedFields, mitarbeiter.FieldBild2Date)
}

// SetBild3Date sets the "Bild3Date" field.
func (m *MitarbeiterMutation) SetBild3Date(t time.Time) {
	m._Bild3Date = &t
}

// Bild3Date returns the value of the "Bild3Date" field in the mutation.
func (m *MitarbeiterMutation) Bild3Date() (r time.Time, exists bool) {
	v := m._Bild3Date
	if v == nil {
		return
	}
	return *v, true
}

// OldBild3Date returns the old "Bild3Date" field's value of the Mitarbeiter entity.
// If the Mitarbeiter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MitarbeiterMutation) OldBild3Date(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBild3Date is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBild3Date requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBild3Date: %w", err)
	}
	return oldValue.Bild3Date, nil
}

// ClearBild3Date clears the value of the "Bild3Date" field.
func (m *MitarbeiterMutation) ClearBild3Date() {
	m._Bild3Date = nil
	m.clearedFields[mitarbeiter.FieldBild3Date] = struct{}{}
}

// Bild3DateCleared returns if the "Bild3Date" field was cleared in this mutation.
func (m *MitarbeiterMutation) Bild3DateCleared() bool {
	_, ok := m.clearedFields[mitarbeiter.FieldBild3Date]
	return ok
}

// ResetBild3Date resets all changes to the "Bild3Date" field.
func (m *MitarbeiterMutation) ResetBild3Date() {
	m._Bild3Date = nil
	delete(m.clearedFields, mitarbeiter.FieldBild3Date)
}

// SetMitarbeiterID sets the "mitarbeiter" edge to the User entity by id.
func (m *MitarbeiterMutation) SetMitarbeiterID(id int) {
	m.mitarbeiter = &id
}

// ClearMitarbeiter clears the "mitarbeiter" edge to the User entity.
func (m *MitarbeiterMutation) ClearMitarbeiter() {
	m.clearedmitarbeiter = true
}

// MitarbeiterCleared reports if the "mitarbeiter" edge to the User entity was cleared.
func (m *MitarbeiterMutation) MitarbeiterCleared() bool {
	return m.clearedmitarbeiter
}

// MitarbeiterID returns the "mitarbeiter" edge ID in the mutation.
func (m *MitarbeiterMutation) MitarbeiterID() (id int, exists bool) {
	if m.mitarbeiter != nil {
		return *m.mitarbeiter, true
	}
	return
}

// MitarbeiterIDs returns the "mitarbeiter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MitarbeiterID instead. It exists only for internal usage by the builders.
func (m *MitarbeiterMutation) MitarbeiterIDs() (ids []int) {
	if id := m.mitarbeiter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMitarbeiter resets all changes to the "mitarbeiter" edge.
func (m *MitarbeiterMutation) ResetMitarbeiter() {
	m.mitarbeiter = nil
	m.clearedmitarbeiter = false
}

// Where appends a list predicates to the MitarbeiterMutation builder.
func (m *MitarbeiterMutation) Where(ps ...predicate.Mitarbeiter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MitarbeiterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MitarbeiterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Mitarbeiter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MitarbeiterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MitarbeiterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Mitarbeiter).
func (m *MitarbeiterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MitarbeiterMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m._Name != nil {
		fields = append(fields, mitarbeiter.FieldName)
	}
	if m._Short != nil {
		fields = append(fields, mitarbeiter.FieldShort)
	}
	if m._Gruppenwahl != nil {
		fields = append(fields, mitarbeiter.FieldGruppenwahl)
	}
	if m._InternTelefon1 != nil {
		fields = append(fields, mitarbeiter.FieldInternTelefon1)
	}
	if m._InternTelefon2 != nil {
		fields = append(fields, mitarbeiter.FieldInternTelefon2)
	}
	if m._FestnetzPrivat != nil {
		fields = append(fields, mitarbeiter.FieldFestnetzPrivat)
	}
	if m._FestnetzAlternativ != nil {
		fields = append(fields, mitarbeiter.FieldFestnetzAlternativ)
	}
	if m._HomeOffice != nil {
		fields = append(fields, mitarbeiter.FieldHomeOffice)
	}
	if m._MobilBusiness != nil {
		fields = append(fields, mitarbeiter.FieldMobilBusiness)
	}
	if m._MobilPrivat != nil {
		fields = append(fields, mitarbeiter.FieldMobilPrivat)
	}
	if m._Email != nil {
		fields = append(fields, mitarbeiter.FieldEmail)
	}
	if m._Azubi != nil {
		fields = append(fields, mitarbeiter.FieldAzubi)
	}
	if m._Geburtstag != nil {
		fields = append(fields, mitarbeiter.FieldGeburtstag)
	}
	if m._Paypal != nil {
		fields = append(fields, mitarbeiter.FieldPaypal)
	}
	if m._Abonniert != nil {
		fields = append(fields, mitarbeiter.FieldAbonniert)
	}
	if m._Geld != nil {
		fields = append(fields, mitarbeiter.FieldGeld)
	}
	if m._Pfand != nil {
		fields = append(fields, mitarbeiter.FieldPfand)
	}
	if m._Dinge != nil {
		fields = append(fields, mitarbeiter.FieldDinge)
	}
	if m._Abgeschickt != nil {
		fields = append(fields, mitarbeiter.FieldAbgeschickt)
	}
	if m._Bild1 != nil {
		fields = append(fields, mitarbeiter.FieldBild1)
	}
	if m._Bild2 != nil {
		fields = append(fields, mitarbeiter.FieldBild2)
	}
	if m._Bild3 != nil {
		fields = append(fields, mitarbeiter.FieldBild3)
	}
	if m._Bild1Date != nil {
		fields = append(fields, mitarbeiter.FieldBild1Date)
	}
	if m._Bild2Date != nil {
		fields = append(fields, mitarbeiter.FieldBild2Date)
	}
	if m._Bild3Date != nil {
		fields = append(fields, mitarbeiter.FieldBild3Date)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MitarbeiterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mitarbeiter.FieldName:
		return m.Name()
	case mitarbeiter.FieldShort:
		return m.Short()
	case mitarbeiter.FieldGruppenwahl:
		return m.Gruppenwahl()
	case mitarbeiter.FieldInternTelefon1:
		return m.InternTelefon1()
	case mitarbeiter.FieldInternTelefon2:
		return m.InternTelefon2()
	case mitarbeiter.FieldFestnetzPrivat:
		return m.FestnetzPrivat()
	case mitarbeiter.FieldFestnetzAlternativ:
		return m.FestnetzAlternativ()
	case mitarbeiter.FieldHomeOffice:
		return m.HomeOffice()
	case mitarbeiter.FieldMobilBusiness:
		return m.MobilBusiness()
	case mitarbeiter.FieldMobilPrivat:
		return m.MobilPrivat()
	case mitarbeiter.FieldEmail:
		return m.Email()
	case mitarbeiter.FieldAzubi:
		return m.Azubi()
	case mitarbeiter.FieldGeburtstag:
		return m.Geburtstag()
	case mitarbeiter.FieldPaypal:
		return m.Paypal()
	case mitarbeiter.FieldAbonniert:
		return m.Abonniert()
	case mitarbeiter.FieldGeld:
		return m.Geld()
	case mitarbeiter.FieldPfand:
		return m.Pfand()
	case mitarbeiter.FieldDinge:
		return m.Dinge()
	case mitarbeiter.FieldAbgeschickt:
		return m.Abgeschickt()
	case mitarbeiter.FieldBild1:
		return m.Bild1()
	case mitarbeiter.FieldBild2:
		return m.Bild2()
	case mitarbeiter.FieldBild3:
		return m.Bild3()
	case mitarbeiter.FieldBild1Date:
		return m.Bild1Date()
	case mitarbeiter.FieldBild2Date:
		return m.Bild2Date()
	case mitarbeiter.FieldBild3Date:
		return m.Bild3Date()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MitarbeiterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mitarbeiter.FieldName:
		return m.OldName(ctx)
	case mitarbeiter.FieldShort:
		return m.OldShort(ctx)
	case mitarbeiter.FieldGruppenwahl:
		return m.OldGruppenwahl(ctx)
	case mitarbeiter.FieldInternTelefon1:
		return m.OldInternTelefon1(ctx)
	case mitarbeiter.FieldInternTelefon2:
		return m.OldInternTelefon2(ctx)
	case mitarbeiter.FieldFestnetzPrivat:
		return m.OldFestnetzPrivat(ctx)
	case mitarbeiter.FieldFestnetzAlternativ:
		return m.OldFestnetzAlternativ(ctx)
	case mitarbeiter.FieldHomeOffice:
		return m.OldHomeOffice(ctx)
	case mitarbeiter.FieldMobilBusiness:
		return m.OldMobilBusiness(ctx)
	case mitarbeiter.FieldMobilPrivat:
		return m.OldMobilPrivat(ctx)
	case mitarbeiter.FieldEmail:
		return m.OldEmail(ctx)
	case mitarbeiter.FieldAzubi:
		return m.OldAzubi(ctx)
	case mitarbeiter.FieldGeburtstag:
		return m.OldGeburtstag(ctx)
	case mitarbeiter.FieldPaypal:
		return m.OldPaypal(ctx)
	case mitarbeiter.FieldAbonniert:
		return m.OldAbonniert(ctx)
	case mitarbeiter.FieldGeld:
		return m.OldGeld(ctx)
	case mitarbeiter.FieldPfand:
		return m.OldPfand(ctx)
	case mitarbeiter.FieldDinge:
		return m.OldDinge(ctx)
	case mitarbeiter.FieldAbgeschickt:
		return m.OldAbgeschickt(ctx)
	case mitarbeiter.FieldBild1:
		return m.OldBild1(ctx)
	case mitarbeiter.FieldBild2:
		return m.OldBild2(ctx)
	case mitarbeiter.FieldBild3:
		return m.OldBild3(ctx)
	case mitarbeiter.FieldBild1Date:
		return m.OldBild1Date(ctx)
	case mitarbeiter.FieldBild2Date:
		return m.OldBild2Date(ctx)
	case mitarbeiter.FieldBild3Date:
		return m.OldBild3Date(ctx)
	}
	return nil, fmt.Errorf("unknown Mitarbeiter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MitarbeiterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mitarbeiter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case mitarbeiter.FieldShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShort(v)
		return nil
	case mitarbeiter.FieldGruppenwahl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGruppenwahl(v)
		return nil
	case mitarbeiter.FieldInternTelefon1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternTelefon1(v)
		return nil
	case mitarbeiter.FieldInternTelefon2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternTelefon2(v)
		return nil
	case mitarbeiter.FieldFestnetzPrivat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFestnetzPrivat(v)
		return nil
	case mitarbeiter.FieldFestnetzAlternativ:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFestnetzAlternativ(v)
		return nil
	case mitarbeiter.FieldHomeOffice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeOffice(v)
		return nil
	case mitarbeiter.FieldMobilBusiness:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobilBusiness(v)
		return nil
	case mitarbeiter.FieldMobilPrivat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobilPrivat(v)
		return nil
	case mitarbeiter.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case mitarbeiter.FieldAzubi:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAzubi(v)
		return nil
	case mitarbeiter.FieldGeburtstag:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeburtstag(v)
		return nil
	case mitarbeiter.FieldPaypal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaypal(v)
		return nil
	case mitarbeiter.FieldAbonniert:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbonniert(v)
		return nil
	case mitarbeiter.FieldGeld:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeld(v)
		return nil
	case mitarbeiter.FieldPfand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPfand(v)
		return nil
	case mitarbeiter.FieldDinge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDinge(v)
		return nil
	case mitarbeiter.FieldAbgeschickt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbgeschickt(v)
		return nil
	case mitarbeiter.FieldBild1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBild1(v)
		return nil
	case mitarbeiter.FieldBild2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBild2(v)
		return nil
	case mitarbeiter.FieldBild3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBild3(v)
		return nil
	case mitarbeiter.FieldBild1Date:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBild1Date(v)
		return nil
	case mitarbeiter.FieldBild2Date:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBild2Date(v)
		return nil
	case mitarbeiter.FieldBild3Date:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBild3Date(v)
		return nil
	}
	return fmt.Errorf("unknown Mitarbeiter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MitarbeiterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MitarbeiterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MitarbeiterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Mitarbeiter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MitarbeiterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mitarbeiter.FieldShort) {
		fields = append(fields, mitarbeiter.FieldShort)
	}
	if m.FieldCleared(mitarbeiter.FieldGruppenwahl) {
		fields = append(fields, mitarbeiter.FieldGruppenwahl)
	}
	if m.FieldCleared(mitarbeiter.FieldInternTelefon1) {
		fields = append(fields, mitarbeiter.FieldInternTelefon1)
	}
	if m.FieldCleared(mitarbeiter.FieldInternTelefon2) {
		fields = append(fields, mitarbeiter.FieldInternTelefon2)
	}
	if m.FieldCleared(mitarbeiter.FieldFestnetzPrivat) {
		fields = append(fields, mitarbeiter.FieldFestnetzPrivat)
	}
	if m.FieldCleared(mitarbeiter.FieldFestnetzAlternativ) {
		fields = append(fields, mitarbeiter.FieldFestnetzAlternativ)
	}
	if m.FieldCleared(mitarbeiter.FieldHomeOffice) {
		fields = append(fields, mitarbeiter.FieldHomeOffice)
	}
	if m.FieldCleared(mitarbeiter.FieldMobilBusiness) {
		fields = append(fields, mitarbeiter.FieldMobilBusiness)
	}
	if m.FieldCleared(mitarbeiter.FieldMobilPrivat) {
		fields = append(fields, mitarbeiter.FieldMobilPrivat)
	}
	if m.FieldCleared(mitarbeiter.FieldEmail) {
		fields = append(fields, mitarbeiter.FieldEmail)
	}
	if m.FieldCleared(mitarbeiter.FieldGeburtstag) {
		fields = append(fields, mitarbeiter.FieldGeburtstag)
	}
	if m.FieldCleared(mitarbeiter.FieldGeld) {
		fields = append(fields, mitarbeiter.FieldGeld)
	}
	if m.FieldCleared(mitarbeiter.FieldPfand) {
		fields = append(fields, mitarbeiter.FieldPfand)
	}
	if m.FieldCleared(mitarbeiter.FieldDinge) {
		fields = append(fields, mitarbeiter.FieldDinge)
	}
	if m.FieldCleared(mitarbeiter.FieldAbgeschickt) {
		fields = append(fields, mitarbeiter.FieldAbgeschickt)
	}
	if m.FieldCleared(mitarbeiter.FieldBild1) {
		fields = append(fields, mitarbeiter.FieldBild1)
	}
	if m.FieldCleared(mitarbeiter.FieldBild2) {
		fields = append(fields, mitarbeiter.FieldBild2)
	}
	if m.FieldCleared(mitarbeiter.FieldBild3) {
		fields = append(fields, mitarbeiter.FieldBild3)
	}
	if m.FieldCleared(mitarbeiter.FieldBild1Date) {
		fields = append(fields, mitarbeiter.FieldBild1Date)
	}
	if m.FieldCleared(mitarbeiter.FieldBild2Date) {
		fields = append(fields, mitarbeiter.FieldBild2Date)
	}
	if m.FieldCleared(mitarbeiter.FieldBild3Date) {
		fields = append(fields, mitarbeiter.FieldBild3Date)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MitarbeiterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MitarbeiterMutation) ClearField(name string) error {
	switch name {
	case mitarbeiter.FieldShort:
		m.ClearShort()
		return nil
	case mitarbeiter.FieldGruppenwahl:
		m.ClearGruppenwahl()
		return nil
	case mitarbeiter.FieldInternTelefon1:
		m.ClearInternTelefon1()
		return nil
	case mitarbeiter.FieldInternTelefon2:
		m.ClearInternTelefon2()
		return nil
	case mitarbeiter.FieldFestnetzPrivat:
		m.ClearFestnetzPrivat()
		return nil
	case mitarbeiter.FieldFestnetzAlternativ:
		m.ClearFestnetzAlternativ()
		return nil
	case mitarbeiter.FieldHomeOffice:
		m.ClearHomeOffice()
		return nil
	case mitarbeiter.FieldMobilBusiness:
		m.ClearMobilBusiness()
		return nil
	case mitarbeiter.FieldMobilPrivat:
		m.ClearMobilPrivat()
		return nil
	case mitarbeiter.FieldEmail:
		m.ClearEmail()
		return nil
	case mitarbeiter.FieldGeburtstag:
		m.ClearGeburtstag()
		return nil
	case mitarbeiter.FieldGeld:
		m.ClearGeld()
		return nil
	case mitarbeiter.FieldPfand:
		m.ClearPfand()
		return nil
	case mitarbeiter.FieldDinge:
		m.ClearDinge()
		return nil
	case mitarbeiter.FieldAbgeschickt:
		m.ClearAbgeschickt()
		return nil
	case mitarbeiter.FieldBild1:
		m.ClearBild1()
		return nil
	case mitarbeiter.FieldBild2:
		m.ClearBild2()
		return nil
	case mitarbeiter.FieldBild3:
		m.ClearBild3()
		return nil
	case mitarbeiter.FieldBild1Date:
		m.ClearBild1Date()
		return nil
	case mitarbeiter.FieldBild2Date:
		m.ClearBild2Date()
		return nil
	case mitarbeiter.FieldBild3Date:
		m.ClearBild3Date()
		return nil
	}
	return fmt.Errorf("unknown Mitarbeiter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MitarbeiterMutation) ResetField(name string) error {
	switch name {
	case mitarbeiter.FieldName:
		m.ResetName()
		return nil
	case mitarbeiter.FieldShort:
		m.ResetShort()
		return nil
	case mitarbeiter.FieldGruppenwahl:
		m.ResetGruppenwahl()
		return nil
	case mitarbeiter.FieldInternTelefon1:
		m.ResetInternTelefon1()
		return nil
	case mitarbeiter.FieldInternTelefon2:
		m.ResetInternTelefon2()
		return nil
	case mitarbeiter.FieldFestnetzPrivat:
		m.ResetFestnetzPrivat()
		return nil
	case mitarbeiter.FieldFestnetzAlternativ:
		m.ResetFestnetzAlternativ()
		return nil
	case mitarbeiter.FieldHomeOffice:
		m.ResetHomeOffice()
		return nil
	case mitarbeiter.FieldMobilBusiness:
		m.ResetMobilBusiness()
		return nil
	case mitarbeiter.FieldMobilPrivat:
		m.ResetMobilPrivat()
		return nil
	case mitarbeiter.FieldEmail:
		m.ResetEmail()
		return nil
	case mitarbeiter.FieldAzubi:
		m.ResetAzubi()
		return nil
	case mitarbeiter.FieldGeburtstag:
		m.ResetGeburtstag()
		return nil
	case mitarbeiter.FieldPaypal:
		m.ResetPaypal()
		return nil
	case mitarbeiter.FieldAbonniert:
		m.ResetAbonniert()
		return nil
	case mitarbeiter.FieldGeld:
		m.ResetGeld()
		return nil
	case mitarbeiter.FieldPfand:
		m.ResetPfand()
		return nil
	case mitarbeiter.FieldDinge:
		m.ResetDinge()
		return nil
	case mitarbeiter.FieldAbgeschickt:
		m.ResetAbgeschickt()
		return nil
	case mitarbeiter.FieldBild1:
		m.ResetBild1()
		return nil
	case mitarbeiter.FieldBild2:
		m.ResetBild2()
		return nil
	case mitarbeiter.FieldBild3:
		m.ResetBild3()
		return nil
	case mitarbeiter.FieldBild1Date:
		m.ResetBild1Date()
		return nil
	case mitarbeiter.FieldBild2Date:
		m.ResetBild2Date()
		return nil
	case mitarbeiter.FieldBild3Date:
		m.ResetBild3Date()
		return nil
	}
	return fmt.Errorf("unknown Mitarbeiter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MitarbeiterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.mitarbeiter != nil {
		edges = append(edges, mitarbeiter.EdgeMitarbeiter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MitarbeiterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mitarbeiter.EdgeMitarbeiter:
		if id := m.mitarbeiter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MitarbeiterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MitarbeiterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MitarbeiterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmitarbeiter {
		edges = append(edges, mitarbeiter.EdgeMitarbeiter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MitarbeiterMutation) EdgeCleared(name string) bool {
	switch name {
	case mitarbeiter.EdgeMitarbeiter:
		return m.clearedmitarbeiter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MitarbeiterMutation) ClearEdge(name string) error {
	switch name {
	case mitarbeiter.EdgeMitarbeiter:
		m.ClearMitarbeiter()
		return nil
	}
	return fmt.Errorf("unknown Mitarbeiter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MitarbeiterMutation) ResetEdge(name string) error {
	switch name {
	case mitarbeiter.EdgeMitarbeiter:
		m.ResetMitarbeiter()
		return nil
	}
	return fmt.Errorf("unknown Mitarbeiter edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Team          *int
	add_Team       *int
	_Mitarbeiter   *string
	_Farbe         *string
	_Ort           *string
	clearedFields  map[string]struct{}
	artikel        map[int]struct{}
	removedartikel map[int]struct{}
	clearedartikel bool
	_Jahr          *int
	cleared_Jahr   bool
	done           bool
	oldValue       func(context.Context) (*Team, error)
	predicates     []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeam sets the "Team" field.
func (m *TeamMutation) SetTeam(i int) {
	m._Team = &i
	m.add_Team = nil
}

// Team returns the value of the "Team" field in the mutation.
func (m *TeamMutation) Team() (r int, exists bool) {
	v := m._Team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeam returns the old "Team" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldTeam(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeam: %w", err)
	}
	return oldValue.Team, nil
}

// AddTeam adds i to the "Team" field.
func (m *TeamMutation) AddTeam(i int) {
	if m.add_Team != nil {
		*m.add_Team += i
	} else {
		m.add_Team = &i
	}
}

// AddedTeam returns the value that was added to the "Team" field in this mutation.
func (m *TeamMutation) AddedTeam() (r int, exists bool) {
	v := m.add_Team
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeam resets all changes to the "Team" field.
func (m *TeamMutation) ResetTeam() {
	m._Team = nil
	m.add_Team = nil
}

// SetMitarbeiter sets the "Mitarbeiter" field.
func (m *TeamMutation) SetMitarbeiter(s string) {
	m._Mitarbeiter = &s
}

// Mitarbeiter returns the value of the "Mitarbeiter" field in the mutation.
func (m *TeamMutation) Mitarbeiter() (r string, exists bool) {
	v := m._Mitarbeiter
	if v == nil {
		return
	}
	return *v, true
}

// OldMitarbeiter returns the old "Mitarbeiter" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldMitarbeiter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMitarbeiter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMitarbeiter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMitarbeiter: %w", err)
	}
	return oldValue.Mitarbeiter, nil
}

// ResetMitarbeiter resets all changes to the "Mitarbeiter" field.
func (m *TeamMutation) ResetMitarbeiter() {
	m._Mitarbeiter = nil
}

// SetFarbe sets the "Farbe" field.
func (m *TeamMutation) SetFarbe(s string) {
	m._Farbe = &s
}

// Farbe returns the value of the "Farbe" field in the mutation.
func (m *TeamMutation) Farbe() (r string, exists bool) {
	v := m._Farbe
	if v == nil {
		return
	}
	return *v, true
}

// OldFarbe returns the old "Farbe" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldFarbe(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFarbe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFarbe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarbe: %w", err)
	}
	return oldValue.Farbe, nil
}

// ResetFarbe resets all changes to the "Farbe" field.
func (m *TeamMutation) ResetFarbe() {
	m._Farbe = nil
}

// SetOrt sets the "Ort" field.
func (m *TeamMutation) SetOrt(s string) {
	m._Ort = &s
}

// Ort returns the value of the "Ort" field in the mutation.
func (m *TeamMutation) Ort() (r string, exists bool) {
	v := m._Ort
	if v == nil {
		return
	}
	return *v, true
}

// OldOrt returns the old "Ort" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldOrt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrt: %w", err)
	}
	return oldValue.Ort, nil
}

// ResetOrt resets all changes to the "Ort" field.
func (m *TeamMutation) ResetOrt() {
	m._Ort = nil
}

// AddArtikelIDs adds the "artikel" edge to the Artikel entity by ids.
func (m *TeamMutation) AddArtikelIDs(ids ...int) {
	if m.artikel == nil {
		m.artikel = make(map[int]struct{})
	}
	for i := range ids {
		m.artikel[ids[i]] = struct{}{}
	}
}

// ClearArtikel clears the "artikel" edge to the Artikel entity.
func (m *TeamMutation) ClearArtikel() {
	m.clearedartikel = true
}

// ArtikelCleared reports if the "artikel" edge to the Artikel entity was cleared.
func (m *TeamMutation) ArtikelCleared() bool {
	return m.clearedartikel
}

// RemoveArtikelIDs removes the "artikel" edge to the Artikel entity by IDs.
func (m *TeamMutation) RemoveArtikelIDs(ids ...int) {
	if m.removedartikel == nil {
		m.removedartikel = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.artikel, ids[i])
		m.removedartikel[ids[i]] = struct{}{}
	}
}

// RemovedArtikel returns the removed IDs of the "artikel" edge to the Artikel entity.
func (m *TeamMutation) RemovedArtikelIDs() (ids []int) {
	for id := range m.removedartikel {
		ids = append(ids, id)
	}
	return
}

// ArtikelIDs returns the "artikel" edge IDs in the mutation.
func (m *TeamMutation) ArtikelIDs() (ids []int) {
	for id := range m.artikel {
		ids = append(ids, id)
	}
	return
}

// ResetArtikel resets all changes to the "artikel" edge.
func (m *TeamMutation) ResetArtikel() {
	m.artikel = nil
	m.clearedartikel = false
	m.removedartikel = nil
}

// SetJahrID sets the "Jahr" edge to the Inventur entity by id.
func (m *TeamMutation) SetJahrID(id int) {
	m._Jahr = &id
}

// ClearJahr clears the "Jahr" edge to the Inventur entity.
func (m *TeamMutation) ClearJahr() {
	m.cleared_Jahr = true
}

// JahrCleared reports if the "Jahr" edge to the Inventur entity was cleared.
func (m *TeamMutation) JahrCleared() bool {
	return m.cleared_Jahr
}

// JahrID returns the "Jahr" edge ID in the mutation.
func (m *TeamMutation) JahrID() (id int, exists bool) {
	if m._Jahr != nil {
		return *m._Jahr, true
	}
	return
}

// JahrIDs returns the "Jahr" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JahrID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) JahrIDs() (ids []int) {
	if id := m._Jahr; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJahr resets all changes to the "Jahr" edge.
func (m *TeamMutation) ResetJahr() {
	m._Jahr = nil
	m.cleared_Jahr = false
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Team != nil {
		fields = append(fields, team.FieldTeam)
	}
	if m._Mitarbeiter != nil {
		fields = append(fields, team.FieldMitarbeiter)
	}
	if m._Farbe != nil {
		fields = append(fields, team.FieldFarbe)
	}
	if m._Ort != nil {
		fields = append(fields, team.FieldOrt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldTeam:
		return m.Team()
	case team.FieldMitarbeiter:
		return m.Mitarbeiter()
	case team.FieldFarbe:
		return m.Farbe()
	case team.FieldOrt:
		return m.Ort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldTeam:
		return m.OldTeam(ctx)
	case team.FieldMitarbeiter:
		return m.OldMitarbeiter(ctx)
	case team.FieldFarbe:
		return m.OldFarbe(ctx)
	case team.FieldOrt:
		return m.OldOrt(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldTeam:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeam(v)
		return nil
	case team.FieldMitarbeiter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMitarbeiter(v)
		return nil
	case team.FieldFarbe:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarbe(v)
		return nil
	case team.FieldOrt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrt(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.add_Team != nil {
		fields = append(fields, team.FieldTeam)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldTeam:
		return m.AddedTeam()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldTeam:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeam(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldTeam:
		m.ResetTeam()
		return nil
	case team.FieldMitarbeiter:
		m.ResetMitarbeiter()
		return nil
	case team.FieldFarbe:
		m.ResetFarbe()
		return nil
	case team.FieldOrt:
		m.ResetOrt()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.artikel != nil {
		edges = append(edges, team.EdgeArtikel)
	}
	if m._Jahr != nil {
		edges = append(edges, team.EdgeJahr)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeArtikel:
		ids := make([]ent.Value, 0, len(m.artikel))
		for id := range m.artikel {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeJahr:
		if id := m._Jahr; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedartikel != nil {
		edges = append(edges, team.EdgeArtikel)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeArtikel:
		ids := make([]ent.Value, 0, len(m.removedartikel))
		for id := range m.removedartikel {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedartikel {
		edges = append(edges, team.EdgeArtikel)
	}
	if m.cleared_Jahr {
		edges = append(edges, team.EdgeJahr)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeArtikel:
		return m.clearedartikel
	case team.EdgeJahr:
		return m.cleared_Jahr
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeJahr:
		m.ClearJahr()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeArtikel:
		m.ResetArtikel()
		return nil
	case team.EdgeJahr:
		m.ResetJahr()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_Name              *string
	_Password          *string
	_Mail              *string
	_Active            *bool
	clearedFields      map[string]struct{}
	mitarbeiter        *int
	clearedmitarbeiter bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *UserMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *UserMutation) ResetName() {
	m._Name = nil
}

// SetPassword sets the "Password" field.
func (m *UserMutation) SetPassword(s string) {
	m._Password = &s
}

// Password returns the value of the "Password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m._Password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "Password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "Password" field.
func (m *UserMutation) ResetPassword() {
	m._Password = nil
}

// SetMail sets the "Mail" field.
func (m *UserMutation) SetMail(s string) {
	m._Mail = &s
}

// Mail returns the value of the "Mail" field in the mutation.
func (m *UserMutation) Mail() (r string, exists bool) {
	v := m._Mail
	if v == nil {
		return
	}
	return *v, true
}

// OldMail returns the old "Mail" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMail: %w", err)
	}
	return oldValue.Mail, nil
}

// ResetMail resets all changes to the "Mail" field.
func (m *UserMutation) ResetMail() {
	m._Mail = nil
}

// SetActive sets the "Active" field.
func (m *UserMutation) SetActive(b bool) {
	m._Active = &b
}

// Active returns the value of the "Active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m._Active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "Active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "Active" field.
func (m *UserMutation) ResetActive() {
	m._Active = nil
}

// SetMitarbeiterID sets the "mitarbeiter" edge to the Mitarbeiter entity by id.
func (m *UserMutation) SetMitarbeiterID(id int) {
	m.mitarbeiter = &id
}

// ClearMitarbeiter clears the "mitarbeiter" edge to the Mitarbeiter entity.
func (m *UserMutation) ClearMitarbeiter() {
	m.clearedmitarbeiter = true
}

// MitarbeiterCleared reports if the "mitarbeiter" edge to the Mitarbeiter entity was cleared.
func (m *UserMutation) MitarbeiterCleared() bool {
	return m.clearedmitarbeiter
}

// MitarbeiterID returns the "mitarbeiter" edge ID in the mutation.
func (m *UserMutation) MitarbeiterID() (id int, exists bool) {
	if m.mitarbeiter != nil {
		return *m.mitarbeiter, true
	}
	return
}

// MitarbeiterIDs returns the "mitarbeiter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MitarbeiterID instead. It exists only for internal usage by the builders.
func (m *UserMutation) MitarbeiterIDs() (ids []int) {
	if id := m.mitarbeiter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMitarbeiter resets all changes to the "mitarbeiter" edge.
func (m *UserMutation) ResetMitarbeiter() {
	m.mitarbeiter = nil
	m.clearedmitarbeiter = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Name != nil {
		fields = append(fields, user.FieldName)
	}
	if m._Password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m._Mail != nil {
		fields = append(fields, user.FieldMail)
	}
	if m._Active != nil {
		fields = append(fields, user.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldPassword:
		return m.Password()
	case user.FieldMail:
		return m.Mail()
	case user.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldMail:
		return m.OldMail(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldMail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMail(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldMail:
		m.ResetMail()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.mitarbeiter != nil {
		edges = append(edges, user.EdgeMitarbeiter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeMitarbeiter:
		if id := m.mitarbeiter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmitarbeiter {
		edges = append(edges, user.EdgeMitarbeiter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeMitarbeiter:
		return m.clearedmitarbeiter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeMitarbeiter:
		m.ClearMitarbeiter()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeMitarbeiter:
		m.ResetMitarbeiter()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VersionMutation represents an operation that mutates the Version nodes in the graph.
type VersionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_CurrentVersion    *float64
	add_CurrentVersion *float64
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Version, error)
	predicates         []predicate.Version
}

var _ ent.Mutation = (*VersionMutation)(nil)

// versionOption allows management of the mutation configuration using functional options.
type versionOption func(*VersionMutation)

// newVersionMutation creates new mutation for the Version entity.
func newVersionMutation(c config, op Op, opts ...versionOption) *VersionMutation {
	m := &VersionMutation{
		config:        c,
		op:            op,
		typ:           TypeVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVersionID sets the ID field of the mutation.
func withVersionID(id int) versionOption {
	return func(m *VersionMutation) {
		var (
			err   error
			once  sync.Once
			value *Version
		)
		m.oldValue = func(ctx context.Context) (*Version, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Version.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVersion sets the old Version of the mutation.
func withVersion(node *Version) versionOption {
	return func(m *VersionMutation) {
		m.oldValue = func(context.Context) (*Version, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VersionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VersionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Version.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCurrentVersion sets the "CurrentVersion" field.
func (m *VersionMutation) SetCurrentVersion(f float64) {
	m._CurrentVersion = &f
	m.add_CurrentVersion = nil
}

// CurrentVersion returns the value of the "CurrentVersion" field in the mutation.
func (m *VersionMutation) CurrentVersion() (r float64, exists bool) {
	v := m._CurrentVersion
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentVersion returns the old "CurrentVersion" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldCurrentVersion(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentVersion: %w", err)
	}
	return oldValue.CurrentVersion, nil
}

// AddCurrentVersion adds f to the "CurrentVersion" field.
func (m *VersionMutation) AddCurrentVersion(f float64) {
	if m.add_CurrentVersion != nil {
		*m.add_CurrentVersion += f
	} else {
		m.add_CurrentVersion = &f
	}
}

// AddedCurrentVersion returns the value that was added to the "CurrentVersion" field in this mutation.
func (m *VersionMutation) AddedCurrentVersion() (r float64, exists bool) {
	v := m.add_CurrentVersion
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentVersion resets all changes to the "CurrentVersion" field.
func (m *VersionMutation) ResetCurrentVersion() {
	m._CurrentVersion = nil
	m.add_CurrentVersion = nil
}

// Where appends a list predicates to the VersionMutation builder.
func (m *VersionMutation) Where(ps ...predicate.Version) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Version, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Version).
func (m *VersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VersionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._CurrentVersion != nil {
		fields = append(fields, version.FieldCurrentVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case version.FieldCurrentVersion:
		return m.CurrentVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case version.FieldCurrentVersion:
		return m.OldCurrentVersion(ctx)
	}
	return nil, fmt.Errorf("unknown Version field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case version.FieldCurrentVersion:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VersionMutation) AddedFields() []string {
	var fields []string
	if m.add_CurrentVersion != nil {
		fields = append(fields, version.FieldCurrentVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case version.FieldCurrentVersion:
		return m.AddedCurrentVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case version.FieldCurrentVersion:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Version numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Version nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VersionMutation) ResetField(name string) error {
	switch name {
	case version.FieldCurrentVersion:
		m.ResetCurrentVersion()
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Version unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Version edge %s", name)
}
